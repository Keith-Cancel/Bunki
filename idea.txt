While it might be a tad slower I could copy a coroutine to and from the stack instead of creating a separate stack to run on.
This does avoid the issue having to deal with the TEB on windows. Also it's technically undocumented so could change on
future versions of windows (unlikely but possible).

If I just assume an avg context size of 512 bytes. Depending on the move sizes the hardware supports:
* 64 -  64 bit moves (Any 64 bit system)
* 32 - 128 bit moves (SSE, NEON ect...)
* 16 - 256 bit moves (AVX)
*  8 - 512 bit moves (AVX512)

Even in the worst case of not having any vector registers 64 moves is not a ton. I could also maybe for large contexts play around with virtual memory
by having mirrored mappings. Although for some OSes might not be a good idea.

This also has the advantage of letting me call functions that generate deep call stacks without worrying about a stack overflow or need a special function
like I was working on to call such functions.
However, I still can run into the issue if I do not dynamically resize the ctx save area if a save ctx happens too deep the context can't be saved, but
instead of killing the process I could gracefully produce an error.

The biggest down side I see is it gets slower the larger the context is. Also slower given the fact I would have to read the stack memory and then
write to the save location. Where as what I have just write the non-volatile registers.

I just realized the biggest problem with this idea. Pointers to data on the stack could be moved when the coroutine is later resumed.
While relative addressing is certainly possible that would require compiler support so would be rather un-ergonomic or would have to use
the heap. Unless I can think of some way to deal with this I think this idea is dead. Short of finding the start of a threads stack and copying
it out, but that stack copy could be much much larger killing context switching performance.

This idea seems workable if a programming language was designed around, but as a C library no go.
